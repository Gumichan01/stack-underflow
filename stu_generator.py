#!/bin/python3

"""
    stu_generator.py: the tag generator
    This is the main program
"""

import sys
import numpy
import stu_misc
import stu_example

def generate_dict():
    """
        Retrieve the dictionary from a file that contains different pairs of (t, e)
        t is the name of the tag
        e is the set of keywords related to the tag, generated by stu_dictionary.py
    """
    pairs = []
    with open(stu_misc.DICT_FILE, 'r') as f:
        for line in f.readlines():
            row  = line.strip(stu_misc.ENDL).split(stu_misc.COMMA)
            pairs.append((row[0], set(row[1].split(' ')) ))
    return pairs

def format_question(qtitle, qcontent):
    """
        Merge the title and the content of the question sent in input into a string
    """
    return stu_misc.concatenate(qtitle, qcontent)

def generate_stats_from(tokens):
    """
        Calculate the intersections between the tokens retrieve from the questions
        and each set of keywords related to its associated tag

        Arg:
            the set og tokens
        Return:
            A list of (t, n)
            t is the name of the tag,
            n is the size of the calculated intersection

    """
    stats = []
    for (t, e) in dict:
        intersect = e.intersection(tokens)
        if intersect != set():
            stats.append((t, len(intersect)))
    return stats

def submit_question(question):
    """
        As it says, it submits a question to generator, so it can generate
        statistics about tags, i.e a list of (t, n) (see generate_stats_from()).

        Arg:
            The question, it is a pair (title, content)
        Return:
            statistics about the question, see generate_stats_from()
    """
    qtitle , qcontent = question
    tokens = set(format_question(qtitle, qcontent).split(' '))
    stats = generate_stats_from(tokens)
    return stats

def get_eligible_tags_from(stats, max = 5):
    """
        Returns at most max eligible tags from the list of pairs (t, n) (see generate_tags())

        Arg:
            statistics about the tags, see generate_stats_from()
            max maximum eligible tags to return (precondition: max > 0)
        Return:
            the list of eligible tags. it contains at most max tags
    """
    if max <= 0:
        raise Exception('Invalid maximum value')
    indexm = 0

    # I don't want to generate more than the size of the dictionary,
    # it the user try to get too much, I use the default value
    max_ = max if max < len(dict) else len(dict)
    marray = numpy.array([0 for i in range(max_)])
    ftags = []
    for i in range(max_):
        for j in range(len(stats)):
            if stats[j][1] > marray[i]:
                marray[i] = stats[j][1]
                indexm = j
        ftags.append(stats[indexm][0])
        stats[indexm] = (stats[indexm][0],0)
        indexm = 0
    return ftags

def main(argv):

    if len(argv) < 2:
        print('\nusage: ', argv[0], 'example-(java|cpp) [max_value]\n')
        raise Exception('Not enough arguments')

    use_sample = argv[1]
    max_value  = int(argv[2]) if len(argv) == 3 else 5

    if max_value <= 0:
        raise Exception('invalid max argument')

    if use_sample == 'example-java':
        q = (stu_example.ex_java_title, stu_example.ex_java_content)
    elif use_sample == 'example-cpp':
        q = (stu_example.ex_cpp_title, stu_example.ex_cpp_content)
    else:
        raise Exception('Invalid sample argument')

    qstats = submit_question(q)
    print(get_eligible_tags_from(qstats, max_value))


# Main program
dict = generate_dict() if len(sys.argv) >= 2 else []
main(sys.argv)
